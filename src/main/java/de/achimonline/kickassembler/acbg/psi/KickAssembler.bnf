{
    parserClass="de.achimonline.kickassembler.acbg.parser.KickAssemblerParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="KickAssembler"
    psiImplClassSuffix="Impl"
    psiPackage="de.achimonline.kickassembler.acbg.psi"
    psiImplPackage="de.achimonline.kickassembler.acbg.psi.impl"

    elementTypeHolderClass="de.achimonline.kickassembler.acbg.psi.KickAssemblerTypes"
    elementTypeClass="de.achimonline.kickassembler.acbg.psi.KickAssemblerElementType"
    tokenTypeClass="de.achimonline.kickassembler.acbg.psi.KickAssemblerTokenType"

}

kickAssemblerFile ::= root*

root ::= (
           compound |
           macroDefinition |
           functionDefinition |

           niladic |

           preprocessorDirective |
           DOT DIRECTIVE |

           LABEL_DEF |
           MULTILABEL_DEF |

           COMMENT_LINE |
           COMMENT_BLOCK |

           DUMMY )

ppExprLeft ::= [NOT] ((basicValue | scopedLabel ) | LEFT_PAREN ppExpr RIGHT_PAREN)

ppExpr ::= ppExprLeft (ppInfixOperator ppExpr)*

preprocessorDirective ::= (
    PREPROCESSOR |
    (PREPROCESSOR_IF | PREPROCESSOR_DEF ) ppExpr
)

defExpr ::= ( ["var" | "const"] LABEL ASSIGN expr ) | expr

forLoop ::= (
    DOT DIRECTIVE_FOR LEFT_PAREN defExprList SEMICOLON exprs SEMICOLON exprs RIGHT_PAREN
    compound
)

encodingDirective ::= DOT DIRECTIVE_ENCODING  ( "\"screencode_mixed\"" | "\"screencode_upper\"" )

private labelsDef ::= LABEL_DEF | MULTILABEL_DEF

dataDefinition ::= DOT DIRECTIVE_DATA exprs

cpuDirective ::= DOT DIRECTIVE_CPU ( "_6502NoIllegals" | "_6502" | "dtv" | "_65c02")

pcAssignment ::= (ASTERISK | DOT DIRECTIVE_PC) ASSIGN expr STRING? "virtual"?

labelAssignment ::= DOT DIRECTIVE_DEF LABEL ASSIGN expr

import ::= ( PREPROCESSOR_IMPORT STRING | dotImport)

private dotImport ::= DOT DIRECTIVE_IMPORT (
    "source" STRING |
    ("binary"|"c64"|"text") STRING [ COMMA expr [ COMMA expr ]]
)

argument ::= LABEL_DEF? HASH? expr

block ::= LEFT_BRACE statement* RIGHT_BRACE

private qualifiedMnemonic ::= MNEMONIC [ DOT (MNEMONIC_EXTENSION | MNEMONIC_EXTENSION_DEPRECATED )]

private twoArguments ::= (argument COMMA argument) | twoArgumentsIndirect

twoArgumentsIndirect ::= LEFT_PAREN argument COMMA argument RIGHT_PAREN

private oneArgument ::= oneArgumentIndirect | argument

oneArgumentIndirect ::= LEFT_PAREN argument RIGHT_PAREN

instruction ::= qualifiedMnemonic [twoArguments | oneArgument]

// cannot include macro definitions
statement ::= (
    directive |
    instruction |
    labelsDef |         // is statement as braceless .if binds solely to it
    import |
    dataDefinition |
    invocation |
    assert |
    block |
    pcAssignment |
    labelAssignment |
    forLoop |
    ifElse |
    while |
    evalExpression |
    returnStatement |
    SEMICOLON
)

returnStatement ::= DOT DIRECTIVE_RETURN [expr]

private directive ::= (
    cpuDirective |
    encodingDirective |
    breakDirective |
    watchDirective |
    alignDirective |
    paramDirective |
    diskDirective |
    enumDirective |
    defineDirective |
    filemodifyDirective |
    modifyDirective |
    namespaceDirective |
    segmentDirective |
    structDirective
)

structDirective ::= DOT DIRECTIVE_STRUCT LABEL LEFT_BRACE identifierList? RIGHT_BRACE

macroDefinition ::= DOT DIRECTIVE_DEF_MACRO invocableDefinition

functionDefinition ::= DOT DIRECTIVE_FUNCTION invocableDefinition

private invocableDefinition ::= (
    LABEL LEFT_PAREN identifierList? RIGHT_PAREN LEFT_BRACE
    ( statement )*
    RIGHT_BRACE
)

bracketed ::= (
    ( LEFT_PAREN expr RIGHT_PAREN )
    | ( LEFT_BRACKET expr RIGHT_BRACKET )
)

// e.g. macro args
identifierList ::= LABEL ( COMMA LABEL )*

private ppInfixOperator ::= EQUAL | NOT_EQUAL | AND | OR

// TODO precendence
infixOperator ::= (
    DOT | PLUS | MINUS | ASTERISK | DIVIDE |
    ppInfixOperator |
    LESS | GREATER | LESS_EQUALS | GREATER_EQUALS |
    BIT_AND | BIT_OR | BIT_XOR |
    SHIFT_LEFT | SHIFT_RIGHT |
    PLUS_EQUAL | MINUS_EQUAL | ASTERISK ASSIGN | DIVIDE_EQUAL |
    ASSIGN
)

prefixOperator ::= MINUS | NOT | BIT_NOT

postfixOperator ::= PLUS_PLUS | MINUS_MINUS

escapedString ::= STRING_ESCAPE_BEGIN ( STRING_VALUE | ESCAPE_CHAR)* STRING_END

basicValue ::= STRING | NUMBER | BOOLEAN | NULL | CHAR | escapedString

private labelExpr ::= LABEL [ LEFT_BRACKET expr RIGHT_BRACKET ]

scopedLabel ::= labelExpr ( DOT labelExpr )*

// left-non-recursive left-factored rule
private exprLeft ::= (
    [ LESS | GREATER ] (
        bracketed | basicValue | invocation | scopedLabel | MULTILABEL | ASTERISK |
        ( prefixOperator exprLeft )
    ) postfixOperator?
)

ternaryRhs ::= QUESTION_MARK expr COLON expr

expr ::= ( exprLeft ( infixOperator expr | ternaryRhs )* )

private exprs ::= expr ( COMMA expr )*

private callable ::= (
    // docs as at v5.16: colon before macro invocation is optional from version 4
    // http://www.theweb.dk/KickAssembler/webhelp/content/ch07s02.html
    ( [COLON] ( scopedLabel | BASIC_UPSTART ) ) | DIRECTIVE_BUILTIN
)

invocation ::= (
    (
        callable LEFT_PAREN exprs? RIGHT_PAREN |
        nArityDirectives |
        assert
    )
)

private nArityDirectives ::= DOT DIRECTIVE_UNARY expr |
        DOT DIRECTIVE_BINARY expr COMMA expr |
        DOT DIRECTIVE_TERNARY expr COMMA expr COMMA expr

assert ::= DOT DIRECTIVE_ASSERT STRING COMMA (block | expr) COMMA (block | expr)

defExprList ::=  defExpr ( COMMA defExpr )*

private compound ::= (statement | block)

ifElse ::= (
    DOT DIRECTIVE_IF LEFT_PAREN expr RIGHT_PAREN compound
    [ "else" compound ]
)

while ::= (
    DOT DIRECTIVE_WHILE LEFT_PAREN expr RIGHT_PAREN compound
)

breakDirective ::= DOT DIRECTIVE_BREAK STRING?

watchDirective ::= DOT DIRECTIVE_WATCH expr [ COMMA expr [ COMMA STRING ] ]

alignDirective ::= DOT DIRECTIVE_ALIGN expr

evalExpression ::= DOT DIRECTIVE_EVAL expr

niladic ::= DOT DIRECTIVE_IMPORTONCE | PREPROCESSOR_IMPORTONCE
segmentDirective ::= DOT (DIRECTIVE_SEGMENT | DIRECTIVE_SEGMENT_DEF) LABEL [parameterMap]

paramDirective ::= DOT DIRECTIVE_PARAM parameterMap

diskDirective ::= DOT DIRECTIVE_DISK [LABEL] [parameterMap] LEFT_BRACE parameterMapList RIGHT_BRACE

enumDirective ::= DOT DIRECTIVE_ENUM LEFT_BRACE parameter (COMMA parameter) RIGHT_BRACE

defineDirective ::= DOT DIRECTIVE_DEFINE LABEL ( COMMA LABEL)* block

filemodifyDirective ::= DOT DIRECTIVE_FILEMODIFY invocation

modifyDirective ::= DOT DIRECTIVE_MODIFY invocation block

namespaceDirective ::= DOT DIRECTIVE_NAMESPACE LABEL block

private parameterMapList ::= parameterMap [ COMMA parameterMapList ]

private parameterList ::= parameter ( COMMA parameter )*

parameterMap ::= LEFT_BRACKET [ parameterList ] RIGHT_BRACKET

parameter ::= LABEL [ASSIGN expr]

