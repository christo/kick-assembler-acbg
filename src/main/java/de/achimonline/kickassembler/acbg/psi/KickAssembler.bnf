{
    parserClass="de.achimonline.kickassembler.acbg.parser.KickAssemblerParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="KickAssembler"
    psiImplClassSuffix="Impl"
    psiPackage="de.achimonline.kickassembler.acbg.psi"
    psiImplPackage="de.achimonline.kickassembler.acbg.psi.impl"

    elementTypeHolderClass="de.achimonline.kickassembler.acbg.psi.KickAssemblerTypes"
    elementTypeClass="de.achimonline.kickassembler.acbg.psi.KickAssemblerElementType"
    tokenTypeClass="de.achimonline.kickassembler.acbg.psi.KickAssemblerTokenType"
}

kickAssemblerFile ::= root*

root ::= (
           compound |
           macroDefinition |

           STRING |
           NUMBER |
           BOOLEAN |
           NULL |

           LEFT_PARENTHESES |
           RIGHT_PARENTHESES |
           LEFT_BRACKET |
           RIGHT_BRACKET |
           LEFT_BRACE |
           RIGHT_BRACE |

           HASH |
           ASSIGN |
           COMMA |
           SEMICOLON |
           LESS_EQUALS |
           GREATER_EQUALS |
           LESS |
           GREATER |
           BIT_AND |
           BIT_OR |
           BIT_XOR |
           BIT_NOT |
           SHIFT_LEFT |
           SHIFT_RIGHT |
           PLUS |
           MINUS |
           ASTERISK |
           DIVIDE |
           NOT_EQUAL |
           EQUAL |
           AND |
           OR |
           NOT |
           PLUS_PLUS |
           MINUS_MINUS |
           PLUS_EQUAL |
           MINUS_EQUAL |
           DIVIDE_EQUAL |
           DOT |
           COLON |
           QUESTION_MARK |

           PREPROCESSOR |
           DIRECTIVE_RETURN |
           DIRECTIVE_DATA |
           DIRECTIVE |

           LABEL_DEF |
           MULTILABEL_DEF |

           LABEL |
           MULTILABEL |

           COMMENT_LINE |
           COMMENT_BLOCK |

           DUMMY )

encodingDirective ::= (
    DIRECTIVE_ENCODING  ( "\"screencode_mixed\"" | "\"screencode_upper\"" )
)

private labelsDef ::= LABEL_DEF | MULTILABEL_DEF

dataDefinition ::= DIRECTIVE_DATA exprList

cpuDirective ::= (
    DIRECTIVE_CPU ("_6502NoIllegals" | "_6502" | "dtv" | "_65c02")
)

pcAssignment ::= (
    (ASTERISK | ".pc") ASSIGN expr STRING? "virtual"?
)

labelAssignment ::= DIRECTIVE_DEF LABEL ASSIGN expr

import ::= PREPROCESSOR_IMPORT STRING

argument ::= LABEL_DEF? HASH? expr

block ::= LEFT_BRACE statement* RIGHT_BRACE

private qualifiedMnemonic ::= MNEMONIC [ MNEMONIC_EXTENSION | MNEMONIC_EXTENSION_DEPRECATED ]

instruction ::= (
    ( qualifiedMnemonic argument COMMA argument ) |
    ( qualifiedMnemonic argument ) |
    qualifiedMnemonic
)

// cannot include macro definitions
statement ::= (
    // making label definition into a statement because braceless .if binds solely to it
    labelsDef |
    import |
    dataDefinition |
    invocation |
    block |
    pcAssignment |
    labelAssignment |
    directive |
    forLoop |
    ifElse |
    while |
    instruction
)

private directive ::= (
    cpuDirective |
    encodingDirective |
    breakDirective |
    watchDirective
)

macroDefinition ::= (
    DIRECTIVE_DEF_MACRO LABEL LEFT_PARENTHESES identifierList? RIGHT_PARENTHESES LEFT_BRACE
    ( statement )*
    RIGHT_BRACE
)

bracketed ::= (
    ( LEFT_PARENTHESES expr RIGHT_PARENTHESES )
    | ( LEFT_BRACKET expr RIGHT_BRACKET )
)

// e.g. macro args
identifierList ::= LABEL ( COMMA LABEL )*

infixOperator ::= (
    PLUS | MINUS | ASTERISK | DIVIDE |
    EQUAL | LESS | GREATER | LESS_EQUALS | GREATER_EQUALS | NOT_EQUAL |
    BIT_AND | BIT_OR | BIT_XOR |
    AND | OR |
    SHIFT_LEFT | SHIFT_RIGHT |
    PLUS_EQUAL | MINUS_EQUAL | ASTERISK ASSIGN | DIVIDE_EQUAL
)

prefixOperator ::= MINUS | NOT | BIT_NOT

postfixOperator ::= PLUS_PLUS | MINUS_MINUS

escapedString ::= STRING_ESCAPE_BEGIN ( STRING_VALUE | ESCAPE_CHAR)* STRING_END

basicValue ::= STRING | NUMBER | BOOLEAN | NULL | escapedString

private labelExpr ::= LABEL [ LEFT_BRACKET expr RIGHT_BRACKET ]

scopedLabel ::= labelExpr ( DOT labelExpr )*

// left-non-recursive left-factored rule
private exprLeft ::= (
    [ LESS | GREATER ] (
        bracketed | basicValue | invocation | scopedLabel | MULTILABEL | ASTERISK |
        ( prefixOperator exprLeft )
    ) postfixOperator?
)

expr ::= ( exprLeft ( infixOperator expr )* )

exprList ::= expr ( COMMA expr )*

private callable ::= (
    ( [COLON] ( scopedLabel | BASIC_UPSTART ) ) | DIRECTIVE_BUILTIN
)

invocation ::= (
    // docs as at v5.16: colon before macro invocation is optional from version 4
    // http://www.theweb.dk/KickAssembler/webhelp/content/ch07s02.html
    callable LEFT_PARENTHESES exprList? RIGHT_PARENTHESES
)

private declarationKeyword ::= "var" | "const"

defExpr ::= ( declarationKeyword? LABEL ASSIGN expr ) | expr

defExprList ::=  defExpr ( COMMA defExpr )*

forLoop ::= (
    // TODO need lots of test cases around the expression legality
    DIRECTIVE_FOR LEFT_PARENTHESES defExprList SEMICOLON exprList SEMICOLON exprList RIGHT_PARENTHESES
    compound
)

private compound ::= (statement | block) SEMICOLON?

// TODO .if else .if ...
ifElse ::= (
    DIRECTIVE_IF LEFT_PARENTHESES expr RIGHT_PARENTHESES compound
    [ "else" compound ]
)

while ::= (
    DIRECTIVE_WHILE LEFT_PARENTHESES expr RIGHT_PARENTHESES compound
)

breakDirective ::= DIRECTIVE_BREAK STRING?

watchDirective ::= DIRECTIVE_WATCH expr [ COMMA expr [ COMMA STRING ] ]