{
    parserClass="de.achimonline.kickassembler.acbg.parser.KickAssemblerParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="KickAssembler"
    psiImplClassSuffix="Impl"
    psiPackage="de.achimonline.kickassembler.acbg.psi"
    psiImplPackage="de.achimonline.kickassembler.acbg.psi.impl"

    elementTypeHolderClass="de.achimonline.kickassembler.acbg.psi.KickAssemblerTypes"
    elementTypeClass="de.achimonline.kickassembler.acbg.psi.KickAssemblerElementType"
    tokenTypeClass="de.achimonline.kickassembler.acbg.psi.KickAssemblerTokenType"

}

kickAssemblerFile ::= root*

root ::= (
           compound |
           macroDefinition |
           functionDefinition |
           pseudoCommandDef |
           importOnce |

           DOT DIRECTIVE |

           COMMENT_LINE |
           COMMENT_BLOCK |

           DUMMY )

private labelDef ::= AT? LABEL_DEF

ppExprLeft ::= [BANG] ((basicValue | scopedLabel ) | LEFT_PAREN ppExpr RIGHT_PAREN)

ppExpr ::= ppExprLeft (ppInfixOperator ppExpr)*

preprocessorDirective ::= (
    PREPROCESSOR |
    (PREPROCESSOR_IF | PREPROCESSOR_DEF ) ppExpr
)

defExpr ::= ( ["var" | "const"] LABEL ASSIGN expr ) | expr

forLoop ::= (
    DOT DIRECTIVE_FOR LEFT_PAREN defExprList SEMICOLON exprs SEMICOLON exprs RIGHT_PAREN
    compound
)

encodingDirective ::= DOT DIRECTIVE_ENCODING
( "\"screencode_mixed\"" | "\"screencode_upper\"" | "\"petscii_mixed\"" |  "\"petscii_upper\"" | "\"ascii\"")

multilabel ::= BANG LABEL? (PLUS|MINUS)+

multilabelDef ::= BANG (LABEL_DEF | COLON)

private labelsDef ::= labelDef | multilabelDef

dataDefinition ::= DOT DIRECTIVE_DATA exprs

cpuDirective ::= DOT DIRECTIVE_CPU ( "_6502NoIllegals" | "_6502" | "dtv" | "_65c02")

pcAssignment ::= (ASTERISK | DOT DIRECTIVE_PC) ASSIGN expr STRING? "virtual"?

pseudoPcAssignment ::= DOT DIRECTIVE_PSEUDOPC expr block

labelAssignment ::= DOT DIRECTIVE_DEF LABEL ASSIGN expr

import ::= ( PREPROCESSOR_IMPORT STRING | dotImport)

private dotImport ::= DOT DIRECTIVE_IMPORT (
    "source" STRING |
    ("binary"|"c64"|"text") STRING [ COMMA expr [ COMMA expr ]]
)

argument ::= expr | HASH? expr | labelDef? HASH? expr

block ::= (
    LEFT_BRACE
    (statement | macroDefinition | functionDefinition | preprocessorDirective | pseudoCommandDef)*
    RIGHT_BRACE
)

private qualifiedMnemonic ::= MNEMONIC [ DOT (MNEMONIC_EXTENSION | MNEMONIC_EXTENSION_DEPRECATED )]

private twoArguments ::= (argument COMMA argument) | twoArgumentsIndirect

twoArgumentsIndirect ::= LEFT_PAREN argument COMMA argument RIGHT_PAREN

private oneArgument ::= oneArgumentIndirect | argument

oneArgumentIndirect ::= LEFT_PAREN argument RIGHT_PAREN

instruction ::= qualifiedMnemonic instructionArguments

private instructionArguments ::= [twoArguments | oneArgument]

// cannot include macro definitions
statement ::= (
    directive |
    instruction |
    import |
    dataDefinition |
    invocation |
    pseudoCommand |
    labelsDef |
    assert |
    block |
    pcAssignment |
    pseudoPcAssignment |
    labelAssignment |
    forLoop |
    ifElse |
    while |
    evalExpression |
    returnStatement |
    SEMICOLON
)

returnStatement ::= DOT DIRECTIVE_RETURN [expr]

private directive ::= (
    cpuDirective |
    encodingDirective |
    breakDirective |
    watchDirective |
    alignDirective |
    paramDirective |
    diskDirective |
    enumDirective |
    defineDirective |
    filemodifyDirective |
    modifyDirective |
    namespaceDirective |
    segmentDirective |
    structDirective
)

structDirective ::= DOT DIRECTIVE_STRUCT LABEL LEFT_BRACE identifierList? RIGHT_BRACE

macroDefinition ::= DOT DIRECTIVE_DEF_MACRO invocableDef

functionDefinition ::= DOT DIRECTIVE_FUNCTION invocableDef

private invocableDef ::= AT? LABEL LEFT_PAREN identifierList? RIGHT_PAREN invocableBody

private invocableInternal ::= preprocessorDirective | statement

private invocableBody ::= (LEFT_BRACE ( invocableInternal )+ RIGHT_BRACE) | invocableInternal

pseudoCommandDef ::= DOT DIRECTIVE_PSEUDOCOMMAND AT? LABEL [LABEL (COLON LABEL)*] invocableBody

private pseudoCommandArgs ::= instructionArguments (COLON instructionArguments)*

pseudoCommand ::= /* COLON? */ LABEL [ pseudoCommandArgs ]

bracketed ::= ( LEFT_PAREN expr RIGHT_PAREN ) | ( LEFT_BRACKET expr RIGHT_BRACKET )

// e.g. macro args
identifierList ::= LABEL ( COMMA LABEL )*

private ppInfixOperator ::= EQUAL | NOT_EQUAL | AND | OR

// TODO precendence
infixOperator ::= (
    DOT | PLUS | MINUS | ASTERISK | DIVIDE |
    ppInfixOperator |
    LESS | GREATER | LESS_EQUALS | GREATER_EQUALS |
    BIT_AND | BIT_OR | BIT_XOR |
    SHIFT_LEFT | SHIFT_RIGHT |
    PLUS_EQUAL | MINUS_EQUAL | ASTERISK ASSIGN | DIVIDE_EQUAL |
    ASSIGN
)

prefixOperator ::= MINUS | BANG | BIT_NOT

postfixOperator ::= PLUS PLUS | MINUS MINUS

escapedString ::= STRING_ESCAPE_BEGIN ( STRING_VALUE | ESCAPE_CHAR | ESCAPE_HEX)* STRING_END

private stringLiteral ::= STRING | escapedString

basicValue ::= NUMBER | BOOLEAN | NULL | CHAR | ESCAPE_CHAR| stringLiteral

// TODO figure out if
private labelExpr ::= AT? LABEL [ LEFT_BRACKET expr RIGHT_BRACKET ]

scopedLabel ::= labelExpr ( DOT labelExpr )*

// left-non-recursive left-factored rule
private exprLeft ::= (
    [ LESS | GREATER ] (
        bracketed | basicValue | invocation | scopedLabel | multilabel | ASTERISK |
        ( prefixOperator exprLeft )
    ) postfixOperator?
)

ternaryRhs ::= QUESTION_MARK expr COLON expr

expr ::= ( exprLeft ( infixOperator expr | ternaryRhs )* )

private exprs ::= expr ( COMMA expr )*

// docs as at v5.16: colon before macro invocation is optional from version 4
// http://www.theweb.dk/KickAssembler/webhelp/content/ch07s02.html
private callable ::= ( [COLON] ( scopedLabel | BASIC_UPSTART ) ) | DIRECTIVE_BUILTIN

invocation ::= callable LEFT_PAREN exprs? RIGHT_PAREN | nArityDirectives | assert

private nArityDirectives ::=
    DOT DIRECTIVE_UNARY expr |
    DOT DIRECTIVE_BINARY expr COMMA expr |
    DOT DIRECTIVE_TERNARY expr COMMA expr COMMA expr

assert ::= DOT DIRECTIVE_ASSERT stringLiteral COMMA (block | expr) COMMA (block | expr)

defExprList ::=  defExpr ( COMMA defExpr )*

private compound ::= (statement | preprocessorDirective | block)

ifElse ::= DOT DIRECTIVE_IF LEFT_PAREN expr RIGHT_PAREN compound [ "else" compound ]

while ::= DOT DIRECTIVE_WHILE LEFT_PAREN expr RIGHT_PAREN compound

breakDirective ::= DOT DIRECTIVE_BREAK STRING?

watchDirective ::= DOT DIRECTIVE_WATCH expr [ COMMA expr [ COMMA STRING ] ]

alignDirective ::= DOT DIRECTIVE_ALIGN expr

evalExpression ::= DOT DIRECTIVE_EVAL expr

importOnce ::= DOT DIRECTIVE_IMPORTONCE | PREPROCESSOR_IMPORTONCE

segmentDirective ::= DOT (DIRECTIVE_SEGMENT | DIRECTIVE_SEGMENT_DEF) LABEL [parameterMap] [STRING]

paramDirective ::= DOT DIRECTIVE_PARAM parameterMap

diskDirective ::= DOT DIRECTIVE_DISK [LABEL] [parameterMap] LEFT_BRACE parameterMapList RIGHT_BRACE

enumDirective ::= DOT DIRECTIVE_ENUM LEFT_BRACE parameter (COMMA parameter) RIGHT_BRACE

defineDirective ::= DOT DIRECTIVE_DEFINE LABEL ( COMMA LABEL)* block

filemodifyDirective ::= DOT DIRECTIVE_FILEMODIFY invocation

modifyDirective ::= DOT DIRECTIVE_MODIFY invocation block

namespaceDirective ::= DOT DIRECTIVE_NAMESPACE LABEL block

private parameterMapList ::= parameterMap [ COMMA parameterMapList ]

private parameterList ::= parameter ( COMMA parameter )*

parameterMap ::= LEFT_BRACKET [ parameterList ] RIGHT_BRACKET

parameter ::= LABEL [ASSIGN expr]

