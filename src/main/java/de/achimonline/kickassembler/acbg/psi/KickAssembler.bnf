{
    parserClass="de.achimonline.kickassembler.acbg.parser.KickAssemblerParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="KickAssembler"
    psiImplClassSuffix="Impl"
    psiPackage="de.achimonline.kickassembler.acbg.psi"
    psiImplPackage="de.achimonline.kickassembler.acbg.psi.impl"

    elementTypeHolderClass="de.achimonline.kickassembler.acbg.psi.KickAssemblerTypes"
    elementTypeClass="de.achimonline.kickassembler.acbg.psi.KickAssemblerElementType"
    tokenTypeClass="de.achimonline.kickassembler.acbg.psi.KickAssemblerTokenType"

    tokens = [
        //VAR = "var"
        //CONST = "const"
        //VIRTUAL = "virtual"
        CPU_6502 = "_6502"
        CPU_6502_NO_ILLEGAL = "_6502NoIllegals"
        CPU_65C02 = "_65c02"
        CPU_DTV  = "dtv"
        SCREENCODE_MIXED = "\"screencode_mixed\""
        SCREENCODE_UPPER = "\"screencode_upper\""
    ]

}

kickAssemblerFile ::= root*

root ::= (
           compound |
           macroDefinition |
           functionDefinition |

           niladic |

           PREPROCESSOR |
           DOT DIRECTIVE_RETURN |
           DOT DIRECTIVE |

           LABEL_DEF |
           MULTILABEL_DEF |

           COMMENT_LINE |
           COMMENT_BLOCK |

           DUMMY )

defExpr ::= ( ["var" | "const"] LABEL ASSIGN expr ) | expr

forLoop ::= (
    DOT DIRECTIVE_FOR LEFT_PAREN defExprList SEMICOLON exprs SEMICOLON exprs RIGHT_PAREN
    compound
)

encodingDirective ::= DOT DIRECTIVE_ENCODING  ( SCREENCODE_MIXED | SCREENCODE_UPPER )

private labelsDef ::= LABEL_DEF | MULTILABEL_DEF

dataDefinition ::= DOT DIRECTIVE_DATA exprs

cpuDirective ::= DOT DIRECTIVE_CPU ( CPU_6502_NO_ILLEGAL | CPU_6502 | CPU_DTV | CPU_65C02)

pcAssignment ::= (ASTERISK | DOT DIRECTIVE_PC) ASSIGN expr STRING? "virtual"?

labelAssignment ::= DOT DIRECTIVE_DEF LABEL ASSIGN expr

import ::= ( PREPROCESSOR_IMPORT STRING | dotImport)

private dotImport ::= DOT DIRECTIVE_IMPORT (
    "source" STRING |
    ("binary"|"c64"|"text") STRING [ COMMA expr [ COMMA expr ]]
)

argument ::= LABEL_DEF? HASH? expr

block ::= LEFT_BRACE statement* RIGHT_BRACE

private qualifiedMnemonic ::= MNEMONIC [ DOT (MNEMONIC_EXTENSION | MNEMONIC_EXTENSION_DEPRECATED )]

instruction ::= (
    ( qualifiedMnemonic argument COMMA argument ) |
    ( qualifiedMnemonic argument ) |
    qualifiedMnemonic
)

// cannot include macro definitions
statement ::= (
    // making label definition into a statement because braceless .if binds solely to it
    directive |
    instruction |
    labelsDef |
    import |
    dataDefinition |
    invocation |
    assert |
    block |
    pcAssignment |
    labelAssignment |
    forLoop |
    ifElse |
    while |
    evalExpression
)

private directive ::= (
    cpuDirective |
    encodingDirective |
    breakDirective |
    watchDirective |
    alignDirective |
    paramDirective |
    diskDirective |
    enumDirective |
    defineDirective |
    filemodifyDirective |
    modifyDirective |
    namespaceDirective |
    segmentDirective
)

macroDefinition ::= DOT DIRECTIVE_DEF_MACRO invocableDefinition

functionDefinition ::= DOT DIRECTIVE_FUNCTION invocableDefinition

private invocableDefinition ::= (
    LABEL LEFT_PAREN identifierList? RIGHT_PAREN LEFT_BRACE
        ( statement )*
        [[DIRECTIVE_RETURN] expr]   // only valid in function not macro
        RIGHT_BRACE
)

bracketed ::= (
    ( LEFT_PAREN expr RIGHT_PAREN )
    | ( LEFT_BRACKET expr RIGHT_BRACKET )
)

// e.g. macro args
identifierList ::= LABEL ( COMMA LABEL )*

// TODO precendence
infixOperator ::= (
    PLUS | MINUS | ASTERISK | DIVIDE |
    EQUAL | LESS | GREATER | LESS_EQUALS | GREATER_EQUALS | NOT_EQUAL |
    BIT_AND | BIT_OR | BIT_XOR |
    AND | OR |
    SHIFT_LEFT | SHIFT_RIGHT |
    PLUS_EQUAL | MINUS_EQUAL | ASTERISK ASSIGN | DIVIDE_EQUAL |
    ASSIGN
)

prefixOperator ::= MINUS | NOT | BIT_NOT

postfixOperator ::= PLUS_PLUS | MINUS_MINUS

escapedString ::= STRING_ESCAPE_BEGIN ( STRING_VALUE | ESCAPE_CHAR)* STRING_END

basicValue ::= STRING | NUMBER | BOOLEAN | NULL | escapedString

private labelExpr ::= LABEL [ LEFT_BRACKET expr RIGHT_BRACKET ]

scopedLabel ::= labelExpr ( DOT labelExpr )*

// left-non-recursive left-factored rule
private exprLeft ::= (
    [ LESS | GREATER ] (
        bracketed | basicValue | invocation | scopedLabel | MULTILABEL | ASTERISK |
        ( prefixOperator exprLeft )
    ) postfixOperator?
)

ternaryRhs ::= QUESTION_MARK expr COLON expr

expr ::= ( exprLeft ( infixOperator expr | ternaryRhs )* )

private exprs ::= expr ( COMMA expr )*

private callable ::= (
    // docs as at v5.16: colon before macro invocation is optional from version 4
    // http://www.theweb.dk/KickAssembler/webhelp/content/ch07s02.html
    ( [COLON] ( scopedLabel | BASIC_UPSTART ) ) | DIRECTIVE_BUILTIN
)

invocation ::= (
    (
        callable LEFT_PAREN exprs? RIGHT_PAREN |
        nArityDirectives |
        assert
    )
)

private nArityDirectives ::= DOT DIRECTIVE_UNARY expr |
        DOT DIRECTIVE_BINARY expr COMMA expr |
        DOT DIRECTIVE_TERNARY expr COMMA expr COMMA expr

assert ::= DOT DIRECTIVE_ASSERT STRING COMMA (block | expr) COMMA (block | expr)

defExprList ::=  defExpr ( COMMA defExpr )*

private compound ::= (statement | block) SEMICOLON?

ifElse ::= (
    DOT DIRECTIVE_IF LEFT_PAREN expr RIGHT_PAREN compound
    [ "else" compound ]
)

while ::= (
    DOT DIRECTIVE_WHILE LEFT_PAREN expr RIGHT_PAREN compound
)

breakDirective ::= DOT DIRECTIVE_BREAK STRING?

watchDirective ::= DOT DIRECTIVE_WATCH expr [ COMMA expr [ COMMA STRING ] ]

alignDirective ::= DOT DIRECTIVE_ALIGN expr

evalExpression ::= DOT DIRECTIVE_EVAL expr

niladic ::= DOT DIRECTIVE_IMPORTONCE | PREPROCESSOR_IMPORTONCE
segmentDirective ::= DOT (DIRECTIVE_SEGMENT | DIRECTIVE_SEGMENT_DEF) LABEL [parameterMap]

paramDirective ::= DOT DIRECTIVE_PARAM parameterMap

diskDirective ::= DOT DIRECTIVE_DISK [LABEL] [parameterMap] LEFT_BRACE parameterMapList RIGHT_BRACE

enumDirective ::= DOT DIRECTIVE_ENUM LEFT_BRACE parameter (COMMA parameter) RIGHT_BRACE

defineDirective ::= DOT DIRECTIVE_DEFINE LABEL ( COMMA LABEL)* block

filemodifyDirective ::= DOT DIRECTIVE_FILEMODIFY invocation

modifyDirective ::= DOT DIRECTIVE_MODIFY invocation block

namespaceDirective ::= DOT DIRECTIVE_NAMESPACE LABEL block

private parameterMapList ::= parameterMap [ COMMA parameterMapList ]

private parameterList ::= parameter ( COMMA parameter )*

parameterMap ::= LEFT_BRACKET [ parameterList ] RIGHT_BRACKET

parameter ::= LABEL [ASSIGN expr]

