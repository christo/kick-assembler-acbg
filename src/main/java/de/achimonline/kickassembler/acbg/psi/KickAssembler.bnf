{
    parserClass="de.achimonline.kickassembler.acbg.parser.KickAssemblerParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="KickAssembler"
    psiImplClassSuffix="Impl"
    psiPackage="de.achimonline.kickassembler.acbg.psi"
    psiImplPackage="de.achimonline.kickassembler.acbg.psi.impl"

    elementTypeHolderClass="de.achimonline.kickassembler.acbg.psi.KickAssemblerTypes"
    elementTypeClass="de.achimonline.kickassembler.acbg.psi.KickAssemblerElementType"
    tokenTypeClass="de.achimonline.kickassembler.acbg.psi.KickAssemblerTokenType"
}

kickAssemblerFile ::= root*

root ::= (
           compound |
           macroDefinition |
           functionDefinition |

           niladic |

//           STRING |
//           NUMBER |
//           BOOLEAN |
//           NULL |

           LEFT_PARENTHESES |
           RIGHT_PARENTHESES |
           LEFT_BRACKET |
           RIGHT_BRACKET |
           LEFT_BRACE |
           RIGHT_BRACE |

//           HASH |
//           ASSIGN |
//           COMMA |
//           SEMICOLON |
//           LESS_EQUALS |
//           GREATER_EQUALS |
//           LESS |
//           GREATER |
//           BIT_AND |
//           BIT_OR |
//           BIT_XOR |
//           BIT_NOT |
//           SHIFT_LEFT |
//           SHIFT_RIGHT |
//           PLUS |
//           MINUS |
//           ASTERISK |
//           DIVIDE |
//           NOT_EQUAL |
//           EQUAL |
//           AND |
//           OR |
//           NOT |
//           PLUS_PLUS |
//           MINUS_MINUS |
//           PLUS_EQUAL |
//           MINUS_EQUAL |
//           DIVIDE_EQUAL |
//           DOT |
//           COLON |
           QUESTION_MARK |

           PREPROCESSOR |
           DIRECTIVE_RETURN |
           DIRECTIVE_DATA |
           DIRECTIVE |

           LABEL_DEF |
           MULTILABEL_DEF |

           LABEL |
           MULTILABEL |

           COMMENT_LINE |
           COMMENT_BLOCK |

           DUMMY )

encodingDirective ::= (
    DIRECTIVE_ENCODING  ( "\"screencode_mixed\"" | "\"screencode_upper\"" )
)

private labelsDef ::= LABEL_DEF | MULTILABEL_DEF

dataDefinition ::= DIRECTIVE_DATA exprs

cpuDirective ::= (
    DIRECTIVE_CPU ("_6502NoIllegals" | "_6502" | "dtv" | "_65c02")
)

pcAssignment ::= (
    (ASTERISK | DIRECTIVE_PC) ASSIGN expr STRING? "virtual"?
)

labelAssignment ::= DIRECTIVE_DEF LABEL ASSIGN expr

import ::= ( PREPROCESSOR_IMPORT STRING | dotImport)

private dotImport ::= DIRECTIVE_IMPORT (
    "source" STRING |
    ("binary"|"c64"|"text") STRING [ COMMA expr [ COMMA expr ]]
)

argument ::= LABEL_DEF? HASH? expr

block ::= LEFT_BRACE statement* RIGHT_BRACE

private qualifiedMnemonic ::= MNEMONIC [ MNEMONIC_EXTENSION | MNEMONIC_EXTENSION_DEPRECATED ]

instruction ::= (
    ( qualifiedMnemonic argument COMMA argument ) |
    ( qualifiedMnemonic argument ) |
    qualifiedMnemonic
)

// cannot include macro definitions
statement ::= (
    // making label definition into a statement because braceless .if binds solely to it
    labelsDef |
    import |
    dataDefinition |
    invocation |
    assert |
    block |
    pcAssignment |
    labelAssignment |
    directive |
    forLoop |
    ifElse |
    while |
    evalExpression |
    instruction
)

private directive ::= (
    cpuDirective |
    encodingDirective |
    breakDirective |
    watchDirective |
    alignDirective |
    paramDirective |
    diskDirective |
    enumDirective |
    defineDirective |
    filemodifyDirective |
    modifyDirective |
    namespaceDirective |
    segmentDirective
)

macroDefinition ::= DIRECTIVE_DEF_MACRO invocableDefinition

functionDefinition ::= DIRECTIVE_FUNCTION invocableDefinition

private invocableDefinition ::= (
    LABEL LEFT_PARENTHESES identifierList? RIGHT_PARENTHESES LEFT_BRACE
        ( statement )*
        RIGHT_BRACE
)

bracketed ::= (
    ( LEFT_PARENTHESES expr RIGHT_PARENTHESES )
    | ( LEFT_BRACKET expr RIGHT_BRACKET )
)

// e.g. macro args
identifierList ::= LABEL ( COMMA LABEL )*

// TODO precendence
infixOperator ::= (
    PLUS | MINUS | ASTERISK | DIVIDE |
    EQUAL | LESS | GREATER | LESS_EQUALS | GREATER_EQUALS | NOT_EQUAL |
    BIT_AND | BIT_OR | BIT_XOR |
    AND | OR |
    SHIFT_LEFT | SHIFT_RIGHT |
    PLUS_EQUAL | MINUS_EQUAL | ASTERISK ASSIGN | DIVIDE_EQUAL |
    ASSIGN
)

prefixOperator ::= MINUS | NOT | BIT_NOT

postfixOperator ::= PLUS_PLUS | MINUS_MINUS

escapedString ::= STRING_ESCAPE_BEGIN ( STRING_VALUE | ESCAPE_CHAR)* STRING_END

basicValue ::= STRING | NUMBER | BOOLEAN | NULL | escapedString

private labelExpr ::= LABEL [ LEFT_BRACKET expr RIGHT_BRACKET ]

scopedLabel ::= labelExpr ( DOT labelExpr )*

// left-non-recursive left-factored rule
private exprLeft ::= (
    [ LESS | GREATER ] (
        bracketed | basicValue | invocation | scopedLabel | MULTILABEL | ASTERISK |
        ( prefixOperator exprLeft )
    ) postfixOperator?
)

expr ::= ( exprLeft ( infixOperator expr )* )

private exprs ::= expr ( COMMA expr )*

private callable ::= (
    // docs as at v5.16: colon before macro invocation is optional from version 4
    // http://www.theweb.dk/KickAssembler/webhelp/content/ch07s02.html
    ( [COLON] ( scopedLabel | BASIC_UPSTART ) ) | DIRECTIVE_BUILTIN
)

invocation ::= (
    (
        callable LEFT_PARENTHESES exprs? RIGHT_PARENTHESES |
        nArityDirectives |
        assert
    )
)

private nArityDirectives ::= DIRECTIVE_UNARY expr |
        DIRECTIVE_BINARY expr COMMA expr |
        DIRECTIVE_TERNARY expr COMMA expr COMMA expr

assert ::= DIRECTIVE_ASSERT STRING COMMA (expr | block) COMMA (expr | block)

private declarationKeyword ::= "var" | "const"

defExpr ::= ( declarationKeyword? LABEL ASSIGN expr ) | expr

defExprList ::=  defExpr ( COMMA defExpr )*

forLoop ::= (
    DIRECTIVE_FOR LEFT_PARENTHESES defExprList SEMICOLON exprs SEMICOLON exprs RIGHT_PARENTHESES
    compound
)

private compound ::= (statement | block) SEMICOLON?

ifElse ::= (
    DIRECTIVE_IF LEFT_PARENTHESES expr RIGHT_PARENTHESES compound
    [ "else" compound ]
)

while ::= (
    DIRECTIVE_WHILE LEFT_PARENTHESES expr RIGHT_PARENTHESES compound
)

breakDirective ::= DIRECTIVE_BREAK STRING?

watchDirective ::= DIRECTIVE_WATCH expr [ COMMA expr [ COMMA STRING ] ]

alignDirective ::= DIRECTIVE_ALIGN expr

evalExpression ::= DIRECTIVE_EVAL expr

niladic ::= DIRECTIVE_IMPORTONCE | PREPROCESSOR_IMPORTONCE

segmentDirective ::= (DIRECTIVE_SEGMENT | DIRECTIVE_SEGMENT_DEF) LABEL [parameterMap]

paramDirective ::= DIRECTIVE_PARAM parameterMap

diskDirective ::= DIRECTIVE_DISK [LABEL] [parameterMap] LEFT_BRACE parameterMapList RIGHT_BRACE

enumDirective ::= DIRECTIVE_ENUM LEFT_BRACE parameter (COMMA parameter) RIGHT_BRACE

defineDirective ::= DIRECTIVE_DEFINE LABEL ( COMMA LABEL)* block

filemodifyDirective ::= DIRECTIVE_FILEMODIFY invocation

modifyDirective ::= DIRECTIVE_MODIFY invocation block

namespaceDirective ::= DIRECTIVE_NAMESPACE LABEL block

private parameterMapList ::= parameterMap [ COMMA parameterMapList ]

private parameterList ::= parameter ( COMMA parameter )*

parameterMap ::= LEFT_BRACKET [ parameterList ] RIGHT_BRACKET

parameter ::= LABEL [ASSIGN expr]

